# shell脚本[] [[]] -n -z 的含义解析
## 1、在中括号中，判断变量的值， 加不加双引号    
-z 判断变量的值，是否为空； zero = 0    
* 变量的值，为空，返回0，为true    
* 变量的值，非空，返回1，为false    
&nbsp;&nbsp;&nbsp;&nbsp;   

-n 判断变量的值，是否为空   name = 名字    
* 变量的值，为空，返回1，为false    
* 变量的值，非空，返回0，为true    

__例__    
pid="123"    
  [ -z "$pid" ]  单对中括号，变量必须要加双引号    
 [[ -z $pid ]]   双对括号，变量不用加双引号    

 [ -n "$pid" ]  单对中括号，变量必须要加双引号    
 [[ -z  $pid ]]  双对中括号，变量不用加双引号    


## 2、多个条件判断，[]  和 [[]] 的区别？    
### 2.1：[[  ]]  双对中括号，是不能使用 -a 或者 -o的参数进行比较的；    
__&& 并且  || 或   -a 并且   -o 或者__    
__[[  ]]   条件判断 &&  并且     ||  或__    
[[ 5 -lt 3 || 3 -gt 6 ]]    一个条件，满足，就成立  或者的关系     
[[ 5 -lt 3 || 3 -gt 6 ]]      一个条件满足，就成立  或者的关系     

[[ 5 -lt 3 ]]  ||   [[3 -gt 6 ]]     
[[ 5 -lt 3 ]]  ||   [[3 -gt 6 ]]       写在外面也可以    

__&&  必须两个条件同时满足，和上述一样，这里想说明的问题的是：__    
[[ 5 -lt 3]]  -o [[ 3 -gt 6 ]]                [[ 5 -lt 3 -o 3 -gt 6 ]]     
[[ 5 -lt 3 -a  3 -gt 6 ]]       [[ 5 -lt 3 -a 3 -gt 6 ]]     
-a 和 -o就不成立了，是因为，[[]]  双对中括号，不能使用 -o和 -a的参数    
直接报错：    

### 2.2  [ ]  可以使用 -a   -o的参数，但是必须在 [ ] 中括号内，判断条件，例如：    
[ 5 -lt 3  -o  3 -gt 2 ]     或者条件成立    
[5 -lt 3 ] -o [ 3 -gt 2]    或者条件， 这个不成立，因为必须在中括号内判断    

如果想在中括号外判断两个条件，必须用&& 和 || 比较     
[5 -lt 3 ] ||  [ 3 -gt 2]      
[5 -gt 3 ] &&  [ 3 -gt 2]    成立    

相对的，|| 和 && 不能在中括号内使用，只能在中括号外使用    

## 3、当判断某个变量的值是否满足正则表达式的时候，必须使用[[  ]]  双对中括号,单对中括号，直接报错：




# 提取文件名和目录名的一些方法总结 使用${}
  很多时候在使用Linux的shell时，我们都需要对文件名或目录名进行处理，通常的操作是由路径中提取出文件名，从路径中提取出目录名，提取文件后缀名等等。例如，从路径/dir1/dir2/file.txt中提取也文件名file.txt，提取出目录/dir1/dir2，提取出文件后缀txt等。

下面介绍两种常用的方法来进行相关的操作。

## 一、使用${}
__1、${var##*/}__    
该命令的作用是去掉变量var从左边算起的最后一个'/'字符及其左边的内容，返回从左边算起的最后一个'/'（不含该字符）的右边的内容。使用例子及结果如下：
```shell
# var=/dir1/dir2/file.txt
# echo ${var##*/}
file.txt
```
从运行结果可以看到，使用该命令，可以提取出我们需要的文件名file.txt。    
若使用时在shell程序文件中，可以使用变量来保存这个结果，再加以利用，如file=${var##*/}    

__2、${var##*.}__    
该命令的作用是去掉变量var从左边算起的最后一个'.'字符及其左边的内容，返回从左边算起的最后一个'.'（不含该字符）的右边的内容。使用例子及结果如下：
```shell
# var=/dir1/dir2/file.txt
# echo ${var##*.}
txt
```
从运行结果可以看到，使用该命令，可以提取出我们需要的文件后缀。

如果文件的后缀不仅有一个，例如，file.tar.gz，命令${var##*.}仅能提取最后一个后缀，而我想提取tar.gz时该怎么办？那么就要用下面所说的${var#*.}命令了。    

__3、${var#*.}__    
该命令的作用是去掉变量var从左边算起的第一个'.'字符及其左边的内容，返回从左边算起第一个'.'（不含该字符）的右边部分的内容。使用例子及结果如下：
```shell
# var=/dir1/dir2/file.txt
# echo ${var#*.}
tar.gz
```    
从运行结果可以看到，使用该命令，可以提取出文件的多个后缀。    
&nbsp;&nbsp;&nbsp;&nbsp;

__4、${var%/*}__    
该命令的使用是去掉变量var从右边算起的第一个'/'字符及其右边的内容，返回从右边算起的第一个'/'（不含该字符）的左边的内容。使用例子及结果如下：
```shell
# var=/dir1/dir2/file.txt
# echo ${var%/*}
/dir1/dir2
```    
从运行的结果可以看到，使用该命令，可以提取出我们需要的文件所在的目录    
&nbsp;&nbsp;&nbsp;&nbsp;

__5、${var%%.*}__    
该命令的使用是去掉变量var从右边算起的最后一个'.'字符及其右边的内容，返回从右边算起的最后一个'.'（不含该字符）的左边的内容。使用例子及结果如下：
```shell
# var=/dir1/dir2/file.txt
# echo ${var%%.*}
/dir1/dir2/file
```   
当我们需要建立一个与文件名相同名字（没有后缀）的目录与对应的文件相对应时，就可以使用该命令来进行操作。例如，解压文件的情况就与此类似，我们压缩文件file.zip时，会在与file.zip同级目录下建立一个名为file的目录。     
&nbsp;&nbsp;&nbsp;&nbsp;

__6、${}总结__  


