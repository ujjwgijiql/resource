# shell脚本[] [[]] -n -z 的含义解析
## 1、在中括号中，判断变量的值， 加不加双引号    
-z 判断变量的值，是否为空； zero = 0    
* 变量的值，为空，返回0，为true    
* 变量的值，非空，返回1，为false    
&nbsp;&nbsp;&nbsp;&nbsp;   

-n 判断变量的值，是否为空   name = 名字    
* 变量的值，为空，返回1，为false    
* 变量的值，非空，返回0，为true    

__例__    
pid="123"    
  [ -z "$pid" ]  单对中括号，变量必须要加双引号    
 [[ -z $pid ]]   双对括号，变量不用加双引号    

 [ -n "$pid" ]  单对中括号，变量必须要加双引号    
 [[ -z  $pid ]]  双对中括号，变量不用加双引号    


## 2、多个条件判断，[]  和 [[]] 的区别？    
### 2.1：[[  ]]  双对中括号，是不能使用 -a 或者 -o的参数进行比较的；    
__&& 并且  || 或   -a 并且   -o 或者__    
__[[  ]]   条件判断 &&  并且     ||  或__    
[[ 5 -lt 3 || 3 -gt 6 ]]    一个条件，满足，就成立  或者的关系     
[[ 5 -lt 3 || 3 -gt 6 ]]      一个条件满足，就成立  或者的关系     

[[ 5 -lt 3 ]]  ||   [[3 -gt 6 ]]     
[[ 5 -lt 3 ]]  ||   [[3 -gt 6 ]]       写在外面也可以    

__&&  必须两个条件同时满足，和上述一样，这里想说明的问题的是：__    
[[ 5 -lt 3]]  -o [[ 3 -gt 6 ]]                [[ 5 -lt 3 -o 3 -gt 6 ]]     
[[ 5 -lt 3 -a  3 -gt 6 ]]       [[ 5 -lt 3 -a 3 -gt 6 ]]     
-a 和 -o就不成立了，是因为，[[]]  双对中括号，不能使用 -o和 -a的参数    
直接报错：    

### 2.2  [ ]  可以使用 -a   -o的参数，但是必须在 [ ] 中括号内，判断条件，例如：    
[ 5 -lt 3  -o  3 -gt 2 ]     或者条件成立    
[5 -lt 3 ] -o [ 3 -gt 2]    或者条件， 这个不成立，因为必须在中括号内判断    

如果想在中括号外判断两个条件，必须用&& 和 || 比较     
[5 -lt 3 ] ||  [ 3 -gt 2]      
[5 -gt 3 ] &&  [ 3 -gt 2]    成立    

相对的，|| 和 && 不能在中括号内使用，只能在中括号外使用    

## 3、当判断某个变量的值是否满足正则表达式的时候，必须使用[[  ]]  双对中括号,单对中括号，直接报错：
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
# 提取文件名和目录名的一些方法总结 使用${}
  很多时候在使用Linux的shell时，我们都需要对文件名或目录名进行处理，通常的操作是由路径中提取出文件名，从路径中提取出目录名，提取文件后缀名等等。例如，从路径/dir1/dir2/file.txt中提取也文件名file.txt，提取出目录/dir1/dir2，提取出文件后缀txt等。

下面介绍两种常用的方法来进行相关的操作。

## 一、使用${}
__1、${var##*/}__    
该命令的作用是去掉变量var从左边算起的最后一个'/'字符及其左边的内容，返回从左边算起的最后一个'/'（不含该字符）的右边的内容。使用例子及结果如下：
```shell
# var=/dir1/dir2/file.txt
# echo ${var##*/}
file.txt
```
从运行结果可以看到，使用该命令，可以提取出我们需要的文件名file.txt。    
若使用时在shell程序文件中，可以使用变量来保存这个结果，再加以利用，如file=${var##*/}    
&nbsp;&nbsp;&nbsp;&nbsp;

__2、${var##*.}__    
该命令的作用是去掉变量var从左边算起的最后一个'.'字符及其左边的内容，返回从左边算起的最后一个'.'（不含该字符）的右边的内容。使用例子及结果如下：
```shell
# var=/dir1/dir2/file.txt
# echo ${var##*.}
txt
```
从运行结果可以看到，使用该命令，可以提取出我们需要的文件后缀。

如果文件的后缀不仅有一个，例如，file.tar.gz，命令${var##*.}仅能提取最后一个后缀，而我想提取tar.gz时该怎么办？那么就要用下面所说的${var#*.}命令了。 &nbsp;&nbsp;&nbsp;&nbsp;

__3、${var#*.}__    
该命令的作用是去掉变量var从左边算起的第一个'.'字符及其左边的内容，返回从左边算起第一个'.'（不含该字符）的右边部分的内容。使用例子及结果如下：
```shell
# var=/dir1/dir2/file.txt
# echo ${var#*.}
tar.gz
```    
从运行结果可以看到，使用该命令，可以提取出文件的多个后缀。    
&nbsp;&nbsp;&nbsp;&nbsp;

__4、${var%/*}__    
该命令的使用是去掉变量var从右边算起的第一个'/'字符及其右边的内容，返回从右边算起的第一个'/'（不含该字符）的左边的内容。使用例子及结果如下：
```shell
# var=/dir1/dir2/file.txt
# echo ${var%/*}
/dir1/dir2
```    
从运行的结果可以看到，使用该命令，可以提取出我们需要的文件所在的目录    
&nbsp;&nbsp;&nbsp;&nbsp;

__5、${var%%.*}__    
该命令的使用是去掉变量var从右边算起的最后一个'.'字符及其右边的内容，返回从右边算起的最后一个'.'（不含该字符）的左边的内容。使用例子及结果如下：
```shell
# var=/dir1/dir2/file.txt
# echo ${var%%.*}
/dir1/dir2/file
```   
当我们需要建立一个与文件名相同名字（没有后缀）的目录与对应的文件相对应时，就可以使用该命令来进行操作。例如，解压文件的情况就与此类似，我们压缩文件file.zip时，会在与file.zip同级目录下建立一个名为file的目录。     
&nbsp;&nbsp;&nbsp;&nbsp;

__6、${}总结__  
其实${}并不是专门为提取文件名或目录名的，它的使用是变量的提取和替换等等操作，它可以提取非常多的内容，并不一定是上面五个例子中的'/'或'.'。也就是说，上面的使用方法只是它使用的一个特例。    

看到上面的这些命令，可能会让人感到非常难以理解和记忆，其实不然，它们都是有规律的。    
* #：表示从左边算起第一个
* %：表示从右边算起第一个
* ##：表示从左边算起最后一个
* %%：表示从右边算起最后一个
换句话来说，＃总是表示左边算起，％总是表示右边算起。     

＊：表示要删除的内容，对于#和##的情况，它位于指定的字符（例子中的'/'和'.'）的左边，表于删除指定字符及其左边的内容；对于%和%%的情况，它位于指定的字符（例子中的'/'和'.'）的右边，表示删除指定字符及其右边的内容。这里的'*'的位置不能互换，即不能把*号放在#或##的右边，反之亦然。    

例如：${var%%x*}表示找出从右边算起最后一个字符x，并删除字符x及其右边的字符。    

看到这里，就可以知道，其实该命令的用途非常广泛，上面只是指针文件名和目录名的命名特性来进行提取的一些特例而已。    
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
## 二、basename和dirname
${}并不是专门为提取文件名和目录名设计的命令，那么basename和dirname命令就是专门为做这一件事而已准备的了。    
__1、basename__    
该命令的作用是从路径中提取出文件名，使用方法为basename NAME [SUFFIX]。

1）从路径中提出出文件名（带后缀），例子如下：
```shell
# var=/dir1/dir2/file.txt
# echo ${basename $var}
file.txt
```   
2）从上面命令的用法中可以看到，后缀（SUFFIX）是一个可选项。所以，若只想提取出文件名file，而不带有后缀，还可以在变量的后面加上后缀名，例子如下：
```shell
# var=/dir1/dir2/file.txt
# echo ${basename $var .txt}
file
``` 
__2、dirname__    
该命令的作用是从路径中提取出目录名，使用方法为 dirname NAME
使用例子如下：
```shell
# var=/dir1/dir2/file.txt
# echo $dirname $var
/dir1/dir2
```   
这样就提取出了file.txt文件所在的目录。    

注：该命令不仅能提取出普通文件所的目录，它能提取出任何文件所在的目录，例如目录所在的目录，如下：    
```shell
# var=/dir1/dir2/
# echo $dirname $var
/dir1
```   
它提取出了目录dir2所在的目录dir1.
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
#shell脚本检查端口是否被占用
```shell
port=$1
echo "check $port"
grep_port=`netstat -tlpn | grep "\b$port\b"`
echo "grep port is $grep_port"
if [ -n "$grep_port" ]
then
  echo "port $port is in use"
  exit 1
else
  echo "port is not in use"
fi
```






